// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"employees/ent/department"
	"employees/ent/deptemployee"
	"employees/ent/deptmanager"
	"employees/ent/employee"
	"employees/ent/predicate"
	"employees/ent/salary"
	"employees/ent/title"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDepartment   = "Department"
	TypeDeptEmployee = "DeptEmployee"
	TypeDeptManager  = "DeptManager"
	TypeEmployee     = "Employee"
	TypeSalary       = "Salary"
	TypeTitle        = "Title"
)

// DepartmentMutation represents an operation that mutates the Department nodes in the graph.
type DepartmentMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	name                  *string
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	dept_employees        map[string]struct{}
	removeddept_employees map[string]struct{}
	cleareddept_employees bool
	dept_managers         map[string]struct{}
	removeddept_managers  map[string]struct{}
	cleareddept_managers  bool
	done                  bool
	oldValue              func(context.Context) (*Department, error)
	predicates            []predicate.Department
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows management of the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for the Department entity.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the ID field of the mutation.
func withDepartmentID(id string) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Department entities.
func (m *DepartmentMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DepartmentMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DepartmentMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Department.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *DepartmentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DepartmentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DepartmentMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DepartmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DepartmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DepartmentMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[department.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DepartmentMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[department.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DepartmentMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, department.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DepartmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DepartmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Department entity.
// If the Department object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DepartmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DepartmentMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[department.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DepartmentMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[department.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DepartmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, department.FieldUpdatedAt)
}

// AddDeptEmployeeIDs adds the "dept_employees" edge to the DeptEmployee entity by ids.
func (m *DepartmentMutation) AddDeptEmployeeIDs(ids ...string) {
	if m.dept_employees == nil {
		m.dept_employees = make(map[string]struct{})
	}
	for i := range ids {
		m.dept_employees[ids[i]] = struct{}{}
	}
}

// ClearDeptEmployees clears the "dept_employees" edge to the DeptEmployee entity.
func (m *DepartmentMutation) ClearDeptEmployees() {
	m.cleareddept_employees = true
}

// DeptEmployeesCleared reports if the "dept_employees" edge to the DeptEmployee entity was cleared.
func (m *DepartmentMutation) DeptEmployeesCleared() bool {
	return m.cleareddept_employees
}

// RemoveDeptEmployeeIDs removes the "dept_employees" edge to the DeptEmployee entity by IDs.
func (m *DepartmentMutation) RemoveDeptEmployeeIDs(ids ...string) {
	if m.removeddept_employees == nil {
		m.removeddept_employees = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.dept_employees, ids[i])
		m.removeddept_employees[ids[i]] = struct{}{}
	}
}

// RemovedDeptEmployees returns the removed IDs of the "dept_employees" edge to the DeptEmployee entity.
func (m *DepartmentMutation) RemovedDeptEmployeesIDs() (ids []string) {
	for id := range m.removeddept_employees {
		ids = append(ids, id)
	}
	return
}

// DeptEmployeesIDs returns the "dept_employees" edge IDs in the mutation.
func (m *DepartmentMutation) DeptEmployeesIDs() (ids []string) {
	for id := range m.dept_employees {
		ids = append(ids, id)
	}
	return
}

// ResetDeptEmployees resets all changes to the "dept_employees" edge.
func (m *DepartmentMutation) ResetDeptEmployees() {
	m.dept_employees = nil
	m.cleareddept_employees = false
	m.removeddept_employees = nil
}

// AddDeptManagerIDs adds the "dept_managers" edge to the DeptManager entity by ids.
func (m *DepartmentMutation) AddDeptManagerIDs(ids ...string) {
	if m.dept_managers == nil {
		m.dept_managers = make(map[string]struct{})
	}
	for i := range ids {
		m.dept_managers[ids[i]] = struct{}{}
	}
}

// ClearDeptManagers clears the "dept_managers" edge to the DeptManager entity.
func (m *DepartmentMutation) ClearDeptManagers() {
	m.cleareddept_managers = true
}

// DeptManagersCleared reports if the "dept_managers" edge to the DeptManager entity was cleared.
func (m *DepartmentMutation) DeptManagersCleared() bool {
	return m.cleareddept_managers
}

// RemoveDeptManagerIDs removes the "dept_managers" edge to the DeptManager entity by IDs.
func (m *DepartmentMutation) RemoveDeptManagerIDs(ids ...string) {
	if m.removeddept_managers == nil {
		m.removeddept_managers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.dept_managers, ids[i])
		m.removeddept_managers[ids[i]] = struct{}{}
	}
}

// RemovedDeptManagers returns the removed IDs of the "dept_managers" edge to the DeptManager entity.
func (m *DepartmentMutation) RemovedDeptManagersIDs() (ids []string) {
	for id := range m.removeddept_managers {
		ids = append(ids, id)
	}
	return
}

// DeptManagersIDs returns the "dept_managers" edge IDs in the mutation.
func (m *DepartmentMutation) DeptManagersIDs() (ids []string) {
	for id := range m.dept_managers {
		ids = append(ids, id)
	}
	return
}

// ResetDeptManagers resets all changes to the "dept_managers" edge.
func (m *DepartmentMutation) ResetDeptManagers() {
	m.dept_managers = nil
	m.cleareddept_managers = false
	m.removeddept_managers = nil
}

// Where appends a list predicates to the DepartmentMutation builder.
func (m *DepartmentMutation) Where(ps ...predicate.Department) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DepartmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DepartmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Department, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DepartmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, department.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, department.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, department.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldName:
		return m.Name()
	case department.FieldCreatedAt:
		return m.CreatedAt()
	case department.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldName:
		return m.OldName(ctx)
	case department.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case department.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case department.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case department.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(department.FieldCreatedAt) {
		fields = append(fields, department.FieldCreatedAt)
	}
	if m.FieldCleared(department.FieldUpdatedAt) {
		fields = append(fields, department.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	switch name {
	case department.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case department.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldName:
		m.ResetName()
		return nil
	case department.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case department.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.dept_employees != nil {
		edges = append(edges, department.EdgeDeptEmployees)
	}
	if m.dept_managers != nil {
		edges = append(edges, department.EdgeDeptManagers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeDeptEmployees:
		ids := make([]ent.Value, 0, len(m.dept_employees))
		for id := range m.dept_employees {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeDeptManagers:
		ids := make([]ent.Value, 0, len(m.dept_managers))
		for id := range m.dept_managers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddept_employees != nil {
		edges = append(edges, department.EdgeDeptEmployees)
	}
	if m.removeddept_managers != nil {
		edges = append(edges, department.EdgeDeptManagers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeDeptEmployees:
		ids := make([]ent.Value, 0, len(m.removeddept_employees))
		for id := range m.removeddept_employees {
			ids = append(ids, id)
		}
		return ids
	case department.EdgeDeptManagers:
		ids := make([]ent.Value, 0, len(m.removeddept_managers))
		for id := range m.removeddept_managers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareddept_employees {
		edges = append(edges, department.EdgeDeptEmployees)
	}
	if m.cleareddept_managers {
		edges = append(edges, department.EdgeDeptManagers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	case department.EdgeDeptEmployees:
		return m.cleareddept_employees
	case department.EdgeDeptManagers:
		return m.cleareddept_managers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeDeptEmployees:
		m.ResetDeptEmployees()
		return nil
	case department.EdgeDeptManagers:
		m.ResetDeptManagers()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// DeptEmployeeMutation represents an operation that mutates the DeptEmployee nodes in the graph.
type DeptEmployeeMutation struct {
	config
	op                Op
	typ               string
	id                *string
	from_date         *time.Time
	to_date           *time.Time
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	employee          *string
	clearedemployee   bool
	department        *string
	cleareddepartment bool
	done              bool
	oldValue          func(context.Context) (*DeptEmployee, error)
	predicates        []predicate.DeptEmployee
}

var _ ent.Mutation = (*DeptEmployeeMutation)(nil)

// deptemployeeOption allows management of the mutation configuration using functional options.
type deptemployeeOption func(*DeptEmployeeMutation)

// newDeptEmployeeMutation creates new mutation for the DeptEmployee entity.
func newDeptEmployeeMutation(c config, op Op, opts ...deptemployeeOption) *DeptEmployeeMutation {
	m := &DeptEmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeDeptEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeptEmployeeID sets the ID field of the mutation.
func withDeptEmployeeID(id string) deptemployeeOption {
	return func(m *DeptEmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *DeptEmployee
		)
		m.oldValue = func(ctx context.Context) (*DeptEmployee, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeptEmployee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeptEmployee sets the old DeptEmployee of the mutation.
func withDeptEmployee(node *DeptEmployee) deptemployeeOption {
	return func(m *DeptEmployeeMutation) {
		m.oldValue = func(context.Context) (*DeptEmployee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeptEmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeptEmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeptEmployee entities.
func (m *DeptEmployeeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeptEmployeeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeptEmployeeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeptEmployee.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmployeeID sets the "employee_id" field.
func (m *DeptEmployeeMutation) SetEmployeeID(s string) {
	m.employee = &s
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *DeptEmployeeMutation) EmployeeID() (r string, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the DeptEmployee entity.
// If the DeptEmployee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeptEmployeeMutation) OldEmployeeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ClearEmployeeID clears the value of the "employee_id" field.
func (m *DeptEmployeeMutation) ClearEmployeeID() {
	m.employee = nil
	m.clearedFields[deptemployee.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "employee_id" field was cleared in this mutation.
func (m *DeptEmployeeMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[deptemployee.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *DeptEmployeeMutation) ResetEmployeeID() {
	m.employee = nil
	delete(m.clearedFields, deptemployee.FieldEmployeeID)
}

// SetDepartmentID sets the "department_id" field.
func (m *DeptEmployeeMutation) SetDepartmentID(s string) {
	m.department = &s
}

// DepartmentID returns the value of the "department_id" field in the mutation.
func (m *DeptEmployeeMutation) DepartmentID() (r string, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentID returns the old "department_id" field's value of the DeptEmployee entity.
// If the DeptEmployee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeptEmployeeMutation) OldDepartmentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentID: %w", err)
	}
	return oldValue.DepartmentID, nil
}

// ClearDepartmentID clears the value of the "department_id" field.
func (m *DeptEmployeeMutation) ClearDepartmentID() {
	m.department = nil
	m.clearedFields[deptemployee.FieldDepartmentID] = struct{}{}
}

// DepartmentIDCleared returns if the "department_id" field was cleared in this mutation.
func (m *DeptEmployeeMutation) DepartmentIDCleared() bool {
	_, ok := m.clearedFields[deptemployee.FieldDepartmentID]
	return ok
}

// ResetDepartmentID resets all changes to the "department_id" field.
func (m *DeptEmployeeMutation) ResetDepartmentID() {
	m.department = nil
	delete(m.clearedFields, deptemployee.FieldDepartmentID)
}

// SetFromDate sets the "from_date" field.
func (m *DeptEmployeeMutation) SetFromDate(t time.Time) {
	m.from_date = &t
}

// FromDate returns the value of the "from_date" field in the mutation.
func (m *DeptEmployeeMutation) FromDate() (r time.Time, exists bool) {
	v := m.from_date
	if v == nil {
		return
	}
	return *v, true
}

// OldFromDate returns the old "from_date" field's value of the DeptEmployee entity.
// If the DeptEmployee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeptEmployeeMutation) OldFromDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromDate: %w", err)
	}
	return oldValue.FromDate, nil
}

// ResetFromDate resets all changes to the "from_date" field.
func (m *DeptEmployeeMutation) ResetFromDate() {
	m.from_date = nil
}

// SetToDate sets the "to_date" field.
func (m *DeptEmployeeMutation) SetToDate(t time.Time) {
	m.to_date = &t
}

// ToDate returns the value of the "to_date" field in the mutation.
func (m *DeptEmployeeMutation) ToDate() (r time.Time, exists bool) {
	v := m.to_date
	if v == nil {
		return
	}
	return *v, true
}

// OldToDate returns the old "to_date" field's value of the DeptEmployee entity.
// If the DeptEmployee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeptEmployeeMutation) OldToDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToDate: %w", err)
	}
	return oldValue.ToDate, nil
}

// ResetToDate resets all changes to the "to_date" field.
func (m *DeptEmployeeMutation) ResetToDate() {
	m.to_date = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DeptEmployeeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeptEmployeeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeptEmployee entity.
// If the DeptEmployee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeptEmployeeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DeptEmployeeMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[deptemployee.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DeptEmployeeMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[deptemployee.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeptEmployeeMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, deptemployee.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeptEmployeeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeptEmployeeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeptEmployee entity.
// If the DeptEmployee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeptEmployeeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DeptEmployeeMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[deptemployee.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DeptEmployeeMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[deptemployee.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeptEmployeeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, deptemployee.FieldUpdatedAt)
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *DeptEmployeeMutation) ClearEmployee() {
	m.clearedemployee = true
	m.clearedFields[deptemployee.FieldEmployeeID] = struct{}{}
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *DeptEmployeeMutation) EmployeeCleared() bool {
	return m.EmployeeIDCleared() || m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *DeptEmployeeMutation) EmployeeIDs() (ids []string) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *DeptEmployeeMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// ClearDepartment clears the "department" edge to the Department entity.
func (m *DeptEmployeeMutation) ClearDepartment() {
	m.cleareddepartment = true
	m.clearedFields[deptemployee.FieldDepartmentID] = struct{}{}
}

// DepartmentCleared reports if the "department" edge to the Department entity was cleared.
func (m *DeptEmployeeMutation) DepartmentCleared() bool {
	return m.DepartmentIDCleared() || m.cleareddepartment
}

// DepartmentIDs returns the "department" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *DeptEmployeeMutation) DepartmentIDs() (ids []string) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment resets all changes to the "department" edge.
func (m *DeptEmployeeMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// Where appends a list predicates to the DeptEmployeeMutation builder.
func (m *DeptEmployeeMutation) Where(ps ...predicate.DeptEmployee) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeptEmployeeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeptEmployeeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeptEmployee, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeptEmployeeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeptEmployeeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeptEmployee).
func (m *DeptEmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeptEmployeeMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.employee != nil {
		fields = append(fields, deptemployee.FieldEmployeeID)
	}
	if m.department != nil {
		fields = append(fields, deptemployee.FieldDepartmentID)
	}
	if m.from_date != nil {
		fields = append(fields, deptemployee.FieldFromDate)
	}
	if m.to_date != nil {
		fields = append(fields, deptemployee.FieldToDate)
	}
	if m.created_at != nil {
		fields = append(fields, deptemployee.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, deptemployee.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeptEmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deptemployee.FieldEmployeeID:
		return m.EmployeeID()
	case deptemployee.FieldDepartmentID:
		return m.DepartmentID()
	case deptemployee.FieldFromDate:
		return m.FromDate()
	case deptemployee.FieldToDate:
		return m.ToDate()
	case deptemployee.FieldCreatedAt:
		return m.CreatedAt()
	case deptemployee.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeptEmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deptemployee.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case deptemployee.FieldDepartmentID:
		return m.OldDepartmentID(ctx)
	case deptemployee.FieldFromDate:
		return m.OldFromDate(ctx)
	case deptemployee.FieldToDate:
		return m.OldToDate(ctx)
	case deptemployee.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case deptemployee.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DeptEmployee field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeptEmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deptemployee.FieldEmployeeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case deptemployee.FieldDepartmentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentID(v)
		return nil
	case deptemployee.FieldFromDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromDate(v)
		return nil
	case deptemployee.FieldToDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToDate(v)
		return nil
	case deptemployee.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case deptemployee.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DeptEmployee field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeptEmployeeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeptEmployeeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeptEmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeptEmployee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeptEmployeeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deptemployee.FieldEmployeeID) {
		fields = append(fields, deptemployee.FieldEmployeeID)
	}
	if m.FieldCleared(deptemployee.FieldDepartmentID) {
		fields = append(fields, deptemployee.FieldDepartmentID)
	}
	if m.FieldCleared(deptemployee.FieldCreatedAt) {
		fields = append(fields, deptemployee.FieldCreatedAt)
	}
	if m.FieldCleared(deptemployee.FieldUpdatedAt) {
		fields = append(fields, deptemployee.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeptEmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeptEmployeeMutation) ClearField(name string) error {
	switch name {
	case deptemployee.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case deptemployee.FieldDepartmentID:
		m.ClearDepartmentID()
		return nil
	case deptemployee.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case deptemployee.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown DeptEmployee nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeptEmployeeMutation) ResetField(name string) error {
	switch name {
	case deptemployee.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case deptemployee.FieldDepartmentID:
		m.ResetDepartmentID()
		return nil
	case deptemployee.FieldFromDate:
		m.ResetFromDate()
		return nil
	case deptemployee.FieldToDate:
		m.ResetToDate()
		return nil
	case deptemployee.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case deptemployee.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown DeptEmployee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeptEmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.employee != nil {
		edges = append(edges, deptemployee.EdgeEmployee)
	}
	if m.department != nil {
		edges = append(edges, deptemployee.EdgeDepartment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeptEmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deptemployee.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case deptemployee.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeptEmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeptEmployeeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeptEmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedemployee {
		edges = append(edges, deptemployee.EdgeEmployee)
	}
	if m.cleareddepartment {
		edges = append(edges, deptemployee.EdgeDepartment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeptEmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	case deptemployee.EdgeEmployee:
		return m.clearedemployee
	case deptemployee.EdgeDepartment:
		return m.cleareddepartment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeptEmployeeMutation) ClearEdge(name string) error {
	switch name {
	case deptemployee.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case deptemployee.EdgeDepartment:
		m.ClearDepartment()
		return nil
	}
	return fmt.Errorf("unknown DeptEmployee unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeptEmployeeMutation) ResetEdge(name string) error {
	switch name {
	case deptemployee.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case deptemployee.EdgeDepartment:
		m.ResetDepartment()
		return nil
	}
	return fmt.Errorf("unknown DeptEmployee edge %s", name)
}

// DeptManagerMutation represents an operation that mutates the DeptManager nodes in the graph.
type DeptManagerMutation struct {
	config
	op                Op
	typ               string
	id                *string
	from_date         *time.Time
	to_date           *time.Time
	created_at        *time.Time
	updated_at        *time.Time
	clearedFields     map[string]struct{}
	employee          *string
	clearedemployee   bool
	department        *string
	cleareddepartment bool
	done              bool
	oldValue          func(context.Context) (*DeptManager, error)
	predicates        []predicate.DeptManager
}

var _ ent.Mutation = (*DeptManagerMutation)(nil)

// deptmanagerOption allows management of the mutation configuration using functional options.
type deptmanagerOption func(*DeptManagerMutation)

// newDeptManagerMutation creates new mutation for the DeptManager entity.
func newDeptManagerMutation(c config, op Op, opts ...deptmanagerOption) *DeptManagerMutation {
	m := &DeptManagerMutation{
		config:        c,
		op:            op,
		typ:           TypeDeptManager,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeptManagerID sets the ID field of the mutation.
func withDeptManagerID(id string) deptmanagerOption {
	return func(m *DeptManagerMutation) {
		var (
			err   error
			once  sync.Once
			value *DeptManager
		)
		m.oldValue = func(ctx context.Context) (*DeptManager, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeptManager.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeptManager sets the old DeptManager of the mutation.
func withDeptManager(node *DeptManager) deptmanagerOption {
	return func(m *DeptManagerMutation) {
		m.oldValue = func(context.Context) (*DeptManager, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeptManagerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeptManagerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeptManager entities.
func (m *DeptManagerMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeptManagerMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeptManagerMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeptManager.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmployeeID sets the "employee_id" field.
func (m *DeptManagerMutation) SetEmployeeID(s string) {
	m.employee = &s
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *DeptManagerMutation) EmployeeID() (r string, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the DeptManager entity.
// If the DeptManager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeptManagerMutation) OldEmployeeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ClearEmployeeID clears the value of the "employee_id" field.
func (m *DeptManagerMutation) ClearEmployeeID() {
	m.employee = nil
	m.clearedFields[deptmanager.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "employee_id" field was cleared in this mutation.
func (m *DeptManagerMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[deptmanager.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *DeptManagerMutation) ResetEmployeeID() {
	m.employee = nil
	delete(m.clearedFields, deptmanager.FieldEmployeeID)
}

// SetDepartmentID sets the "department_id" field.
func (m *DeptManagerMutation) SetDepartmentID(s string) {
	m.department = &s
}

// DepartmentID returns the value of the "department_id" field in the mutation.
func (m *DeptManagerMutation) DepartmentID() (r string, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentID returns the old "department_id" field's value of the DeptManager entity.
// If the DeptManager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeptManagerMutation) OldDepartmentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDepartmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDepartmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentID: %w", err)
	}
	return oldValue.DepartmentID, nil
}

// ClearDepartmentID clears the value of the "department_id" field.
func (m *DeptManagerMutation) ClearDepartmentID() {
	m.department = nil
	m.clearedFields[deptmanager.FieldDepartmentID] = struct{}{}
}

// DepartmentIDCleared returns if the "department_id" field was cleared in this mutation.
func (m *DeptManagerMutation) DepartmentIDCleared() bool {
	_, ok := m.clearedFields[deptmanager.FieldDepartmentID]
	return ok
}

// ResetDepartmentID resets all changes to the "department_id" field.
func (m *DeptManagerMutation) ResetDepartmentID() {
	m.department = nil
	delete(m.clearedFields, deptmanager.FieldDepartmentID)
}

// SetFromDate sets the "from_date" field.
func (m *DeptManagerMutation) SetFromDate(t time.Time) {
	m.from_date = &t
}

// FromDate returns the value of the "from_date" field in the mutation.
func (m *DeptManagerMutation) FromDate() (r time.Time, exists bool) {
	v := m.from_date
	if v == nil {
		return
	}
	return *v, true
}

// OldFromDate returns the old "from_date" field's value of the DeptManager entity.
// If the DeptManager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeptManagerMutation) OldFromDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromDate: %w", err)
	}
	return oldValue.FromDate, nil
}

// ResetFromDate resets all changes to the "from_date" field.
func (m *DeptManagerMutation) ResetFromDate() {
	m.from_date = nil
}

// SetToDate sets the "to_date" field.
func (m *DeptManagerMutation) SetToDate(t time.Time) {
	m.to_date = &t
}

// ToDate returns the value of the "to_date" field in the mutation.
func (m *DeptManagerMutation) ToDate() (r time.Time, exists bool) {
	v := m.to_date
	if v == nil {
		return
	}
	return *v, true
}

// OldToDate returns the old "to_date" field's value of the DeptManager entity.
// If the DeptManager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeptManagerMutation) OldToDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToDate: %w", err)
	}
	return oldValue.ToDate, nil
}

// ResetToDate resets all changes to the "to_date" field.
func (m *DeptManagerMutation) ResetToDate() {
	m.to_date = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DeptManagerMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DeptManagerMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DeptManager entity.
// If the DeptManager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeptManagerMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *DeptManagerMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[deptmanager.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *DeptManagerMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[deptmanager.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DeptManagerMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, deptmanager.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *DeptManagerMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *DeptManagerMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the DeptManager entity.
// If the DeptManager object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeptManagerMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *DeptManagerMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[deptmanager.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *DeptManagerMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[deptmanager.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *DeptManagerMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, deptmanager.FieldUpdatedAt)
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *DeptManagerMutation) ClearEmployee() {
	m.clearedemployee = true
	m.clearedFields[deptmanager.FieldEmployeeID] = struct{}{}
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *DeptManagerMutation) EmployeeCleared() bool {
	return m.EmployeeIDCleared() || m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *DeptManagerMutation) EmployeeIDs() (ids []string) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *DeptManagerMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// ClearDepartment clears the "department" edge to the Department entity.
func (m *DeptManagerMutation) ClearDepartment() {
	m.cleareddepartment = true
	m.clearedFields[deptmanager.FieldDepartmentID] = struct{}{}
}

// DepartmentCleared reports if the "department" edge to the Department entity was cleared.
func (m *DeptManagerMutation) DepartmentCleared() bool {
	return m.DepartmentIDCleared() || m.cleareddepartment
}

// DepartmentIDs returns the "department" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *DeptManagerMutation) DepartmentIDs() (ids []string) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment resets all changes to the "department" edge.
func (m *DeptManagerMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// Where appends a list predicates to the DeptManagerMutation builder.
func (m *DeptManagerMutation) Where(ps ...predicate.DeptManager) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeptManagerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeptManagerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeptManager, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeptManagerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeptManagerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeptManager).
func (m *DeptManagerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeptManagerMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.employee != nil {
		fields = append(fields, deptmanager.FieldEmployeeID)
	}
	if m.department != nil {
		fields = append(fields, deptmanager.FieldDepartmentID)
	}
	if m.from_date != nil {
		fields = append(fields, deptmanager.FieldFromDate)
	}
	if m.to_date != nil {
		fields = append(fields, deptmanager.FieldToDate)
	}
	if m.created_at != nil {
		fields = append(fields, deptmanager.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, deptmanager.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeptManagerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deptmanager.FieldEmployeeID:
		return m.EmployeeID()
	case deptmanager.FieldDepartmentID:
		return m.DepartmentID()
	case deptmanager.FieldFromDate:
		return m.FromDate()
	case deptmanager.FieldToDate:
		return m.ToDate()
	case deptmanager.FieldCreatedAt:
		return m.CreatedAt()
	case deptmanager.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeptManagerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deptmanager.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case deptmanager.FieldDepartmentID:
		return m.OldDepartmentID(ctx)
	case deptmanager.FieldFromDate:
		return m.OldFromDate(ctx)
	case deptmanager.FieldToDate:
		return m.OldToDate(ctx)
	case deptmanager.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case deptmanager.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown DeptManager field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeptManagerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deptmanager.FieldEmployeeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case deptmanager.FieldDepartmentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentID(v)
		return nil
	case deptmanager.FieldFromDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromDate(v)
		return nil
	case deptmanager.FieldToDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToDate(v)
		return nil
	case deptmanager.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case deptmanager.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown DeptManager field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeptManagerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeptManagerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeptManagerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeptManager numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeptManagerMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deptmanager.FieldEmployeeID) {
		fields = append(fields, deptmanager.FieldEmployeeID)
	}
	if m.FieldCleared(deptmanager.FieldDepartmentID) {
		fields = append(fields, deptmanager.FieldDepartmentID)
	}
	if m.FieldCleared(deptmanager.FieldCreatedAt) {
		fields = append(fields, deptmanager.FieldCreatedAt)
	}
	if m.FieldCleared(deptmanager.FieldUpdatedAt) {
		fields = append(fields, deptmanager.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeptManagerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeptManagerMutation) ClearField(name string) error {
	switch name {
	case deptmanager.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case deptmanager.FieldDepartmentID:
		m.ClearDepartmentID()
		return nil
	case deptmanager.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case deptmanager.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown DeptManager nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeptManagerMutation) ResetField(name string) error {
	switch name {
	case deptmanager.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case deptmanager.FieldDepartmentID:
		m.ResetDepartmentID()
		return nil
	case deptmanager.FieldFromDate:
		m.ResetFromDate()
		return nil
	case deptmanager.FieldToDate:
		m.ResetToDate()
		return nil
	case deptmanager.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case deptmanager.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown DeptManager field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeptManagerMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.employee != nil {
		edges = append(edges, deptmanager.EdgeEmployee)
	}
	if m.department != nil {
		edges = append(edges, deptmanager.EdgeDepartment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeptManagerMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deptmanager.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	case deptmanager.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeptManagerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeptManagerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeptManagerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedemployee {
		edges = append(edges, deptmanager.EdgeEmployee)
	}
	if m.cleareddepartment {
		edges = append(edges, deptmanager.EdgeDepartment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeptManagerMutation) EdgeCleared(name string) bool {
	switch name {
	case deptmanager.EdgeEmployee:
		return m.clearedemployee
	case deptmanager.EdgeDepartment:
		return m.cleareddepartment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeptManagerMutation) ClearEdge(name string) error {
	switch name {
	case deptmanager.EdgeEmployee:
		m.ClearEmployee()
		return nil
	case deptmanager.EdgeDepartment:
		m.ClearDepartment()
		return nil
	}
	return fmt.Errorf("unknown DeptManager unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeptManagerMutation) ResetEdge(name string) error {
	switch name {
	case deptmanager.EdgeEmployee:
		m.ResetEmployee()
		return nil
	case deptmanager.EdgeDepartment:
		m.ResetDepartment()
		return nil
	}
	return fmt.Errorf("unknown DeptManager edge %s", name)
}

// EmployeeMutation represents an operation that mutates the Employee nodes in the graph.
type EmployeeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	birth_date            *time.Time
	first_name            *string
	last_name             *string
	gender                *employee.Gender
	hire_date             *time.Time
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	dept_employees        map[string]struct{}
	removeddept_employees map[string]struct{}
	cleareddept_employees bool
	dept_managers         map[string]struct{}
	removeddept_managers  map[string]struct{}
	cleareddept_managers  bool
	salaries              map[string]struct{}
	removedsalaries       map[string]struct{}
	clearedsalaries       bool
	titles                map[string]struct{}
	removedtitles         map[string]struct{}
	clearedtitles         bool
	done                  bool
	oldValue              func(context.Context) (*Employee, error)
	predicates            []predicate.Employee
}

var _ ent.Mutation = (*EmployeeMutation)(nil)

// employeeOption allows management of the mutation configuration using functional options.
type employeeOption func(*EmployeeMutation)

// newEmployeeMutation creates new mutation for the Employee entity.
func newEmployeeMutation(c config, op Op, opts ...employeeOption) *EmployeeMutation {
	m := &EmployeeMutation{
		config:        c,
		op:            op,
		typ:           TypeEmployee,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmployeeID sets the ID field of the mutation.
func withEmployeeID(id string) employeeOption {
	return func(m *EmployeeMutation) {
		var (
			err   error
			once  sync.Once
			value *Employee
		)
		m.oldValue = func(ctx context.Context) (*Employee, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Employee.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmployee sets the old Employee of the mutation.
func withEmployee(node *Employee) employeeOption {
	return func(m *EmployeeMutation) {
		m.oldValue = func(context.Context) (*Employee, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmployeeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmployeeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Employee entities.
func (m *EmployeeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmployeeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmployeeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Employee.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBirthDate sets the "birth_date" field.
func (m *EmployeeMutation) SetBirthDate(t time.Time) {
	m.birth_date = &t
}

// BirthDate returns the value of the "birth_date" field in the mutation.
func (m *EmployeeMutation) BirthDate() (r time.Time, exists bool) {
	v := m.birth_date
	if v == nil {
		return
	}
	return *v, true
}

// OldBirthDate returns the old "birth_date" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldBirthDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBirthDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBirthDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBirthDate: %w", err)
	}
	return oldValue.BirthDate, nil
}

// ResetBirthDate resets all changes to the "birth_date" field.
func (m *EmployeeMutation) ResetBirthDate() {
	m.birth_date = nil
}

// SetFirstName sets the "first_name" field.
func (m *EmployeeMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *EmployeeMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *EmployeeMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *EmployeeMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *EmployeeMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *EmployeeMutation) ResetLastName() {
	m.last_name = nil
}

// SetGender sets the "gender" field.
func (m *EmployeeMutation) SetGender(e employee.Gender) {
	m.gender = &e
}

// Gender returns the value of the "gender" field in the mutation.
func (m *EmployeeMutation) Gender() (r employee.Gender, exists bool) {
	v := m.gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "gender" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldGender(ctx context.Context) (v employee.Gender, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "gender" field.
func (m *EmployeeMutation) ResetGender() {
	m.gender = nil
}

// SetHireDate sets the "hire_date" field.
func (m *EmployeeMutation) SetHireDate(t time.Time) {
	m.hire_date = &t
}

// HireDate returns the value of the "hire_date" field in the mutation.
func (m *EmployeeMutation) HireDate() (r time.Time, exists bool) {
	v := m.hire_date
	if v == nil {
		return
	}
	return *v, true
}

// OldHireDate returns the old "hire_date" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldHireDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHireDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHireDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHireDate: %w", err)
	}
	return oldValue.HireDate, nil
}

// ResetHireDate resets all changes to the "hire_date" field.
func (m *EmployeeMutation) ResetHireDate() {
	m.hire_date = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EmployeeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmployeeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *EmployeeMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[employee.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *EmployeeMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[employee.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmployeeMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, employee.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmployeeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmployeeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Employee entity.
// If the Employee object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmployeeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *EmployeeMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[employee.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *EmployeeMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[employee.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmployeeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, employee.FieldUpdatedAt)
}

// AddDeptEmployeeIDs adds the "dept_employees" edge to the DeptEmployee entity by ids.
func (m *EmployeeMutation) AddDeptEmployeeIDs(ids ...string) {
	if m.dept_employees == nil {
		m.dept_employees = make(map[string]struct{})
	}
	for i := range ids {
		m.dept_employees[ids[i]] = struct{}{}
	}
}

// ClearDeptEmployees clears the "dept_employees" edge to the DeptEmployee entity.
func (m *EmployeeMutation) ClearDeptEmployees() {
	m.cleareddept_employees = true
}

// DeptEmployeesCleared reports if the "dept_employees" edge to the DeptEmployee entity was cleared.
func (m *EmployeeMutation) DeptEmployeesCleared() bool {
	return m.cleareddept_employees
}

// RemoveDeptEmployeeIDs removes the "dept_employees" edge to the DeptEmployee entity by IDs.
func (m *EmployeeMutation) RemoveDeptEmployeeIDs(ids ...string) {
	if m.removeddept_employees == nil {
		m.removeddept_employees = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.dept_employees, ids[i])
		m.removeddept_employees[ids[i]] = struct{}{}
	}
}

// RemovedDeptEmployees returns the removed IDs of the "dept_employees" edge to the DeptEmployee entity.
func (m *EmployeeMutation) RemovedDeptEmployeesIDs() (ids []string) {
	for id := range m.removeddept_employees {
		ids = append(ids, id)
	}
	return
}

// DeptEmployeesIDs returns the "dept_employees" edge IDs in the mutation.
func (m *EmployeeMutation) DeptEmployeesIDs() (ids []string) {
	for id := range m.dept_employees {
		ids = append(ids, id)
	}
	return
}

// ResetDeptEmployees resets all changes to the "dept_employees" edge.
func (m *EmployeeMutation) ResetDeptEmployees() {
	m.dept_employees = nil
	m.cleareddept_employees = false
	m.removeddept_employees = nil
}

// AddDeptManagerIDs adds the "dept_managers" edge to the DeptManager entity by ids.
func (m *EmployeeMutation) AddDeptManagerIDs(ids ...string) {
	if m.dept_managers == nil {
		m.dept_managers = make(map[string]struct{})
	}
	for i := range ids {
		m.dept_managers[ids[i]] = struct{}{}
	}
}

// ClearDeptManagers clears the "dept_managers" edge to the DeptManager entity.
func (m *EmployeeMutation) ClearDeptManagers() {
	m.cleareddept_managers = true
}

// DeptManagersCleared reports if the "dept_managers" edge to the DeptManager entity was cleared.
func (m *EmployeeMutation) DeptManagersCleared() bool {
	return m.cleareddept_managers
}

// RemoveDeptManagerIDs removes the "dept_managers" edge to the DeptManager entity by IDs.
func (m *EmployeeMutation) RemoveDeptManagerIDs(ids ...string) {
	if m.removeddept_managers == nil {
		m.removeddept_managers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.dept_managers, ids[i])
		m.removeddept_managers[ids[i]] = struct{}{}
	}
}

// RemovedDeptManagers returns the removed IDs of the "dept_managers" edge to the DeptManager entity.
func (m *EmployeeMutation) RemovedDeptManagersIDs() (ids []string) {
	for id := range m.removeddept_managers {
		ids = append(ids, id)
	}
	return
}

// DeptManagersIDs returns the "dept_managers" edge IDs in the mutation.
func (m *EmployeeMutation) DeptManagersIDs() (ids []string) {
	for id := range m.dept_managers {
		ids = append(ids, id)
	}
	return
}

// ResetDeptManagers resets all changes to the "dept_managers" edge.
func (m *EmployeeMutation) ResetDeptManagers() {
	m.dept_managers = nil
	m.cleareddept_managers = false
	m.removeddept_managers = nil
}

// AddSalaryIDs adds the "salaries" edge to the Salary entity by ids.
func (m *EmployeeMutation) AddSalaryIDs(ids ...string) {
	if m.salaries == nil {
		m.salaries = make(map[string]struct{})
	}
	for i := range ids {
		m.salaries[ids[i]] = struct{}{}
	}
}

// ClearSalaries clears the "salaries" edge to the Salary entity.
func (m *EmployeeMutation) ClearSalaries() {
	m.clearedsalaries = true
}

// SalariesCleared reports if the "salaries" edge to the Salary entity was cleared.
func (m *EmployeeMutation) SalariesCleared() bool {
	return m.clearedsalaries
}

// RemoveSalaryIDs removes the "salaries" edge to the Salary entity by IDs.
func (m *EmployeeMutation) RemoveSalaryIDs(ids ...string) {
	if m.removedsalaries == nil {
		m.removedsalaries = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.salaries, ids[i])
		m.removedsalaries[ids[i]] = struct{}{}
	}
}

// RemovedSalaries returns the removed IDs of the "salaries" edge to the Salary entity.
func (m *EmployeeMutation) RemovedSalariesIDs() (ids []string) {
	for id := range m.removedsalaries {
		ids = append(ids, id)
	}
	return
}

// SalariesIDs returns the "salaries" edge IDs in the mutation.
func (m *EmployeeMutation) SalariesIDs() (ids []string) {
	for id := range m.salaries {
		ids = append(ids, id)
	}
	return
}

// ResetSalaries resets all changes to the "salaries" edge.
func (m *EmployeeMutation) ResetSalaries() {
	m.salaries = nil
	m.clearedsalaries = false
	m.removedsalaries = nil
}

// AddTitleIDs adds the "titles" edge to the Title entity by ids.
func (m *EmployeeMutation) AddTitleIDs(ids ...string) {
	if m.titles == nil {
		m.titles = make(map[string]struct{})
	}
	for i := range ids {
		m.titles[ids[i]] = struct{}{}
	}
}

// ClearTitles clears the "titles" edge to the Title entity.
func (m *EmployeeMutation) ClearTitles() {
	m.clearedtitles = true
}

// TitlesCleared reports if the "titles" edge to the Title entity was cleared.
func (m *EmployeeMutation) TitlesCleared() bool {
	return m.clearedtitles
}

// RemoveTitleIDs removes the "titles" edge to the Title entity by IDs.
func (m *EmployeeMutation) RemoveTitleIDs(ids ...string) {
	if m.removedtitles == nil {
		m.removedtitles = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.titles, ids[i])
		m.removedtitles[ids[i]] = struct{}{}
	}
}

// RemovedTitles returns the removed IDs of the "titles" edge to the Title entity.
func (m *EmployeeMutation) RemovedTitlesIDs() (ids []string) {
	for id := range m.removedtitles {
		ids = append(ids, id)
	}
	return
}

// TitlesIDs returns the "titles" edge IDs in the mutation.
func (m *EmployeeMutation) TitlesIDs() (ids []string) {
	for id := range m.titles {
		ids = append(ids, id)
	}
	return
}

// ResetTitles resets all changes to the "titles" edge.
func (m *EmployeeMutation) ResetTitles() {
	m.titles = nil
	m.clearedtitles = false
	m.removedtitles = nil
}

// Where appends a list predicates to the EmployeeMutation builder.
func (m *EmployeeMutation) Where(ps ...predicate.Employee) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmployeeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmployeeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Employee, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmployeeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmployeeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Employee).
func (m *EmployeeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmployeeMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.birth_date != nil {
		fields = append(fields, employee.FieldBirthDate)
	}
	if m.first_name != nil {
		fields = append(fields, employee.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, employee.FieldLastName)
	}
	if m.gender != nil {
		fields = append(fields, employee.FieldGender)
	}
	if m.hire_date != nil {
		fields = append(fields, employee.FieldHireDate)
	}
	if m.created_at != nil {
		fields = append(fields, employee.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, employee.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmployeeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case employee.FieldBirthDate:
		return m.BirthDate()
	case employee.FieldFirstName:
		return m.FirstName()
	case employee.FieldLastName:
		return m.LastName()
	case employee.FieldGender:
		return m.Gender()
	case employee.FieldHireDate:
		return m.HireDate()
	case employee.FieldCreatedAt:
		return m.CreatedAt()
	case employee.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmployeeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case employee.FieldBirthDate:
		return m.OldBirthDate(ctx)
	case employee.FieldFirstName:
		return m.OldFirstName(ctx)
	case employee.FieldLastName:
		return m.OldLastName(ctx)
	case employee.FieldGender:
		return m.OldGender(ctx)
	case employee.FieldHireDate:
		return m.OldHireDate(ctx)
	case employee.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case employee.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Employee field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case employee.FieldBirthDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBirthDate(v)
		return nil
	case employee.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case employee.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case employee.FieldGender:
		v, ok := value.(employee.Gender)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case employee.FieldHireDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHireDate(v)
		return nil
	case employee.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case employee.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmployeeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmployeeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmployeeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmployeeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(employee.FieldCreatedAt) {
		fields = append(fields, employee.FieldCreatedAt)
	}
	if m.FieldCleared(employee.FieldUpdatedAt) {
		fields = append(fields, employee.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmployeeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmployeeMutation) ClearField(name string) error {
	switch name {
	case employee.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case employee.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Employee nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmployeeMutation) ResetField(name string) error {
	switch name {
	case employee.FieldBirthDate:
		m.ResetBirthDate()
		return nil
	case employee.FieldFirstName:
		m.ResetFirstName()
		return nil
	case employee.FieldLastName:
		m.ResetLastName()
		return nil
	case employee.FieldGender:
		m.ResetGender()
		return nil
	case employee.FieldHireDate:
		m.ResetHireDate()
		return nil
	case employee.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case employee.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Employee field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmployeeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.dept_employees != nil {
		edges = append(edges, employee.EdgeDeptEmployees)
	}
	if m.dept_managers != nil {
		edges = append(edges, employee.EdgeDeptManagers)
	}
	if m.salaries != nil {
		edges = append(edges, employee.EdgeSalaries)
	}
	if m.titles != nil {
		edges = append(edges, employee.EdgeTitles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmployeeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeDeptEmployees:
		ids := make([]ent.Value, 0, len(m.dept_employees))
		for id := range m.dept_employees {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeDeptManagers:
		ids := make([]ent.Value, 0, len(m.dept_managers))
		for id := range m.dept_managers {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeSalaries:
		ids := make([]ent.Value, 0, len(m.salaries))
		for id := range m.salaries {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeTitles:
		ids := make([]ent.Value, 0, len(m.titles))
		for id := range m.titles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmployeeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeddept_employees != nil {
		edges = append(edges, employee.EdgeDeptEmployees)
	}
	if m.removeddept_managers != nil {
		edges = append(edges, employee.EdgeDeptManagers)
	}
	if m.removedsalaries != nil {
		edges = append(edges, employee.EdgeSalaries)
	}
	if m.removedtitles != nil {
		edges = append(edges, employee.EdgeTitles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmployeeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case employee.EdgeDeptEmployees:
		ids := make([]ent.Value, 0, len(m.removeddept_employees))
		for id := range m.removeddept_employees {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeDeptManagers:
		ids := make([]ent.Value, 0, len(m.removeddept_managers))
		for id := range m.removeddept_managers {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeSalaries:
		ids := make([]ent.Value, 0, len(m.removedsalaries))
		for id := range m.removedsalaries {
			ids = append(ids, id)
		}
		return ids
	case employee.EdgeTitles:
		ids := make([]ent.Value, 0, len(m.removedtitles))
		for id := range m.removedtitles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmployeeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareddept_employees {
		edges = append(edges, employee.EdgeDeptEmployees)
	}
	if m.cleareddept_managers {
		edges = append(edges, employee.EdgeDeptManagers)
	}
	if m.clearedsalaries {
		edges = append(edges, employee.EdgeSalaries)
	}
	if m.clearedtitles {
		edges = append(edges, employee.EdgeTitles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmployeeMutation) EdgeCleared(name string) bool {
	switch name {
	case employee.EdgeDeptEmployees:
		return m.cleareddept_employees
	case employee.EdgeDeptManagers:
		return m.cleareddept_managers
	case employee.EdgeSalaries:
		return m.clearedsalaries
	case employee.EdgeTitles:
		return m.clearedtitles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmployeeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Employee unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmployeeMutation) ResetEdge(name string) error {
	switch name {
	case employee.EdgeDeptEmployees:
		m.ResetDeptEmployees()
		return nil
	case employee.EdgeDeptManagers:
		m.ResetDeptManagers()
		return nil
	case employee.EdgeSalaries:
		m.ResetSalaries()
		return nil
	case employee.EdgeTitles:
		m.ResetTitles()
		return nil
	}
	return fmt.Errorf("unknown Employee edge %s", name)
}

// SalaryMutation represents an operation that mutates the Salary nodes in the graph.
type SalaryMutation struct {
	config
	op              Op
	typ             string
	id              *string
	salary          *int32
	addsalary       *int32
	from_date       *time.Time
	to_date         *time.Time
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	employee        *string
	clearedemployee bool
	done            bool
	oldValue        func(context.Context) (*Salary, error)
	predicates      []predicate.Salary
}

var _ ent.Mutation = (*SalaryMutation)(nil)

// salaryOption allows management of the mutation configuration using functional options.
type salaryOption func(*SalaryMutation)

// newSalaryMutation creates new mutation for the Salary entity.
func newSalaryMutation(c config, op Op, opts ...salaryOption) *SalaryMutation {
	m := &SalaryMutation{
		config:        c,
		op:            op,
		typ:           TypeSalary,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSalaryID sets the ID field of the mutation.
func withSalaryID(id string) salaryOption {
	return func(m *SalaryMutation) {
		var (
			err   error
			once  sync.Once
			value *Salary
		)
		m.oldValue = func(ctx context.Context) (*Salary, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Salary.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSalary sets the old Salary of the mutation.
func withSalary(node *Salary) salaryOption {
	return func(m *SalaryMutation) {
		m.oldValue = func(context.Context) (*Salary, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SalaryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SalaryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Salary entities.
func (m *SalaryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SalaryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SalaryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Salary.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmployeeID sets the "employee_id" field.
func (m *SalaryMutation) SetEmployeeID(s string) {
	m.employee = &s
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *SalaryMutation) EmployeeID() (r string, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the Salary entity.
// If the Salary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SalaryMutation) OldEmployeeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ClearEmployeeID clears the value of the "employee_id" field.
func (m *SalaryMutation) ClearEmployeeID() {
	m.employee = nil
	m.clearedFields[salary.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "employee_id" field was cleared in this mutation.
func (m *SalaryMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[salary.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *SalaryMutation) ResetEmployeeID() {
	m.employee = nil
	delete(m.clearedFields, salary.FieldEmployeeID)
}

// SetSalary sets the "salary" field.
func (m *SalaryMutation) SetSalary(i int32) {
	m.salary = &i
	m.addsalary = nil
}

// Salary returns the value of the "salary" field in the mutation.
func (m *SalaryMutation) Salary() (r int32, exists bool) {
	v := m.salary
	if v == nil {
		return
	}
	return *v, true
}

// OldSalary returns the old "salary" field's value of the Salary entity.
// If the Salary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SalaryMutation) OldSalary(ctx context.Context) (v int32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSalary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSalary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSalary: %w", err)
	}
	return oldValue.Salary, nil
}

// AddSalary adds i to the "salary" field.
func (m *SalaryMutation) AddSalary(i int32) {
	if m.addsalary != nil {
		*m.addsalary += i
	} else {
		m.addsalary = &i
	}
}

// AddedSalary returns the value that was added to the "salary" field in this mutation.
func (m *SalaryMutation) AddedSalary() (r int32, exists bool) {
	v := m.addsalary
	if v == nil {
		return
	}
	return *v, true
}

// ResetSalary resets all changes to the "salary" field.
func (m *SalaryMutation) ResetSalary() {
	m.salary = nil
	m.addsalary = nil
}

// SetFromDate sets the "from_date" field.
func (m *SalaryMutation) SetFromDate(t time.Time) {
	m.from_date = &t
}

// FromDate returns the value of the "from_date" field in the mutation.
func (m *SalaryMutation) FromDate() (r time.Time, exists bool) {
	v := m.from_date
	if v == nil {
		return
	}
	return *v, true
}

// OldFromDate returns the old "from_date" field's value of the Salary entity.
// If the Salary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SalaryMutation) OldFromDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromDate: %w", err)
	}
	return oldValue.FromDate, nil
}

// ResetFromDate resets all changes to the "from_date" field.
func (m *SalaryMutation) ResetFromDate() {
	m.from_date = nil
}

// SetToDate sets the "to_date" field.
func (m *SalaryMutation) SetToDate(t time.Time) {
	m.to_date = &t
}

// ToDate returns the value of the "to_date" field in the mutation.
func (m *SalaryMutation) ToDate() (r time.Time, exists bool) {
	v := m.to_date
	if v == nil {
		return
	}
	return *v, true
}

// OldToDate returns the old "to_date" field's value of the Salary entity.
// If the Salary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SalaryMutation) OldToDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToDate: %w", err)
	}
	return oldValue.ToDate, nil
}

// ResetToDate resets all changes to the "to_date" field.
func (m *SalaryMutation) ResetToDate() {
	m.to_date = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SalaryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SalaryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Salary entity.
// If the Salary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SalaryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *SalaryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[salary.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *SalaryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[salary.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SalaryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, salary.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SalaryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SalaryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Salary entity.
// If the Salary object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SalaryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *SalaryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[salary.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *SalaryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[salary.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SalaryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, salary.FieldUpdatedAt)
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *SalaryMutation) ClearEmployee() {
	m.clearedemployee = true
	m.clearedFields[salary.FieldEmployeeID] = struct{}{}
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *SalaryMutation) EmployeeCleared() bool {
	return m.EmployeeIDCleared() || m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *SalaryMutation) EmployeeIDs() (ids []string) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *SalaryMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// Where appends a list predicates to the SalaryMutation builder.
func (m *SalaryMutation) Where(ps ...predicate.Salary) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SalaryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SalaryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Salary, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SalaryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SalaryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Salary).
func (m *SalaryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SalaryMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.employee != nil {
		fields = append(fields, salary.FieldEmployeeID)
	}
	if m.salary != nil {
		fields = append(fields, salary.FieldSalary)
	}
	if m.from_date != nil {
		fields = append(fields, salary.FieldFromDate)
	}
	if m.to_date != nil {
		fields = append(fields, salary.FieldToDate)
	}
	if m.created_at != nil {
		fields = append(fields, salary.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, salary.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SalaryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case salary.FieldEmployeeID:
		return m.EmployeeID()
	case salary.FieldSalary:
		return m.Salary()
	case salary.FieldFromDate:
		return m.FromDate()
	case salary.FieldToDate:
		return m.ToDate()
	case salary.FieldCreatedAt:
		return m.CreatedAt()
	case salary.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SalaryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case salary.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case salary.FieldSalary:
		return m.OldSalary(ctx)
	case salary.FieldFromDate:
		return m.OldFromDate(ctx)
	case salary.FieldToDate:
		return m.OldToDate(ctx)
	case salary.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case salary.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Salary field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SalaryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case salary.FieldEmployeeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case salary.FieldSalary:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSalary(v)
		return nil
	case salary.FieldFromDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromDate(v)
		return nil
	case salary.FieldToDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToDate(v)
		return nil
	case salary.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case salary.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Salary field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SalaryMutation) AddedFields() []string {
	var fields []string
	if m.addsalary != nil {
		fields = append(fields, salary.FieldSalary)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SalaryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case salary.FieldSalary:
		return m.AddedSalary()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SalaryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case salary.FieldSalary:
		v, ok := value.(int32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSalary(v)
		return nil
	}
	return fmt.Errorf("unknown Salary numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SalaryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(salary.FieldEmployeeID) {
		fields = append(fields, salary.FieldEmployeeID)
	}
	if m.FieldCleared(salary.FieldCreatedAt) {
		fields = append(fields, salary.FieldCreatedAt)
	}
	if m.FieldCleared(salary.FieldUpdatedAt) {
		fields = append(fields, salary.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SalaryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SalaryMutation) ClearField(name string) error {
	switch name {
	case salary.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case salary.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case salary.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Salary nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SalaryMutation) ResetField(name string) error {
	switch name {
	case salary.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case salary.FieldSalary:
		m.ResetSalary()
		return nil
	case salary.FieldFromDate:
		m.ResetFromDate()
		return nil
	case salary.FieldToDate:
		m.ResetToDate()
		return nil
	case salary.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case salary.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Salary field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SalaryMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.employee != nil {
		edges = append(edges, salary.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SalaryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case salary.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SalaryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SalaryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SalaryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedemployee {
		edges = append(edges, salary.EdgeEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SalaryMutation) EdgeCleared(name string) bool {
	switch name {
	case salary.EdgeEmployee:
		return m.clearedemployee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SalaryMutation) ClearEdge(name string) error {
	switch name {
	case salary.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown Salary unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SalaryMutation) ResetEdge(name string) error {
	switch name {
	case salary.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown Salary edge %s", name)
}

// TitleMutation represents an operation that mutates the Title nodes in the graph.
type TitleMutation struct {
	config
	op              Op
	typ             string
	id              *string
	title           *string
	from_date       *time.Time
	to_date         *time.Time
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	employee        *string
	clearedemployee bool
	done            bool
	oldValue        func(context.Context) (*Title, error)
	predicates      []predicate.Title
}

var _ ent.Mutation = (*TitleMutation)(nil)

// titleOption allows management of the mutation configuration using functional options.
type titleOption func(*TitleMutation)

// newTitleMutation creates new mutation for the Title entity.
func newTitleMutation(c config, op Op, opts ...titleOption) *TitleMutation {
	m := &TitleMutation{
		config:        c,
		op:            op,
		typ:           TypeTitle,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTitleID sets the ID field of the mutation.
func withTitleID(id string) titleOption {
	return func(m *TitleMutation) {
		var (
			err   error
			once  sync.Once
			value *Title
		)
		m.oldValue = func(ctx context.Context) (*Title, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Title.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTitle sets the old Title of the mutation.
func withTitle(node *Title) titleOption {
	return func(m *TitleMutation) {
		m.oldValue = func(context.Context) (*Title, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TitleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TitleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Title entities.
func (m *TitleMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TitleMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TitleMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Title.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEmployeeID sets the "employee_id" field.
func (m *TitleMutation) SetEmployeeID(s string) {
	m.employee = &s
}

// EmployeeID returns the value of the "employee_id" field in the mutation.
func (m *TitleMutation) EmployeeID() (r string, exists bool) {
	v := m.employee
	if v == nil {
		return
	}
	return *v, true
}

// OldEmployeeID returns the old "employee_id" field's value of the Title entity.
// If the Title object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TitleMutation) OldEmployeeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmployeeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmployeeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmployeeID: %w", err)
	}
	return oldValue.EmployeeID, nil
}

// ClearEmployeeID clears the value of the "employee_id" field.
func (m *TitleMutation) ClearEmployeeID() {
	m.employee = nil
	m.clearedFields[title.FieldEmployeeID] = struct{}{}
}

// EmployeeIDCleared returns if the "employee_id" field was cleared in this mutation.
func (m *TitleMutation) EmployeeIDCleared() bool {
	_, ok := m.clearedFields[title.FieldEmployeeID]
	return ok
}

// ResetEmployeeID resets all changes to the "employee_id" field.
func (m *TitleMutation) ResetEmployeeID() {
	m.employee = nil
	delete(m.clearedFields, title.FieldEmployeeID)
}

// SetTitle sets the "title" field.
func (m *TitleMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *TitleMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Title entity.
// If the Title object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TitleMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *TitleMutation) ResetTitle() {
	m.title = nil
}

// SetFromDate sets the "from_date" field.
func (m *TitleMutation) SetFromDate(t time.Time) {
	m.from_date = &t
}

// FromDate returns the value of the "from_date" field in the mutation.
func (m *TitleMutation) FromDate() (r time.Time, exists bool) {
	v := m.from_date
	if v == nil {
		return
	}
	return *v, true
}

// OldFromDate returns the old "from_date" field's value of the Title entity.
// If the Title object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TitleMutation) OldFromDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromDate: %w", err)
	}
	return oldValue.FromDate, nil
}

// ResetFromDate resets all changes to the "from_date" field.
func (m *TitleMutation) ResetFromDate() {
	m.from_date = nil
}

// SetToDate sets the "to_date" field.
func (m *TitleMutation) SetToDate(t time.Time) {
	m.to_date = &t
}

// ToDate returns the value of the "to_date" field in the mutation.
func (m *TitleMutation) ToDate() (r time.Time, exists bool) {
	v := m.to_date
	if v == nil {
		return
	}
	return *v, true
}

// OldToDate returns the old "to_date" field's value of the Title entity.
// If the Title object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TitleMutation) OldToDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldToDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldToDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToDate: %w", err)
	}
	return oldValue.ToDate, nil
}

// ResetToDate resets all changes to the "to_date" field.
func (m *TitleMutation) ResetToDate() {
	m.to_date = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TitleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TitleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Title entity.
// If the Title object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TitleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TitleMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[title.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TitleMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[title.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TitleMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, title.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TitleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TitleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Title entity.
// If the Title object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TitleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TitleMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[title.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TitleMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[title.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TitleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, title.FieldUpdatedAt)
}

// ClearEmployee clears the "employee" edge to the Employee entity.
func (m *TitleMutation) ClearEmployee() {
	m.clearedemployee = true
	m.clearedFields[title.FieldEmployeeID] = struct{}{}
}

// EmployeeCleared reports if the "employee" edge to the Employee entity was cleared.
func (m *TitleMutation) EmployeeCleared() bool {
	return m.EmployeeIDCleared() || m.clearedemployee
}

// EmployeeIDs returns the "employee" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmployeeID instead. It exists only for internal usage by the builders.
func (m *TitleMutation) EmployeeIDs() (ids []string) {
	if id := m.employee; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmployee resets all changes to the "employee" edge.
func (m *TitleMutation) ResetEmployee() {
	m.employee = nil
	m.clearedemployee = false
}

// Where appends a list predicates to the TitleMutation builder.
func (m *TitleMutation) Where(ps ...predicate.Title) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TitleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TitleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Title, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TitleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TitleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Title).
func (m *TitleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TitleMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.employee != nil {
		fields = append(fields, title.FieldEmployeeID)
	}
	if m.title != nil {
		fields = append(fields, title.FieldTitle)
	}
	if m.from_date != nil {
		fields = append(fields, title.FieldFromDate)
	}
	if m.to_date != nil {
		fields = append(fields, title.FieldToDate)
	}
	if m.created_at != nil {
		fields = append(fields, title.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, title.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TitleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case title.FieldEmployeeID:
		return m.EmployeeID()
	case title.FieldTitle:
		return m.Title()
	case title.FieldFromDate:
		return m.FromDate()
	case title.FieldToDate:
		return m.ToDate()
	case title.FieldCreatedAt:
		return m.CreatedAt()
	case title.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TitleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case title.FieldEmployeeID:
		return m.OldEmployeeID(ctx)
	case title.FieldTitle:
		return m.OldTitle(ctx)
	case title.FieldFromDate:
		return m.OldFromDate(ctx)
	case title.FieldToDate:
		return m.OldToDate(ctx)
	case title.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case title.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Title field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TitleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case title.FieldEmployeeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmployeeID(v)
		return nil
	case title.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case title.FieldFromDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromDate(v)
		return nil
	case title.FieldToDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToDate(v)
		return nil
	case title.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case title.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Title field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TitleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TitleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TitleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Title numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TitleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(title.FieldEmployeeID) {
		fields = append(fields, title.FieldEmployeeID)
	}
	if m.FieldCleared(title.FieldCreatedAt) {
		fields = append(fields, title.FieldCreatedAt)
	}
	if m.FieldCleared(title.FieldUpdatedAt) {
		fields = append(fields, title.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TitleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TitleMutation) ClearField(name string) error {
	switch name {
	case title.FieldEmployeeID:
		m.ClearEmployeeID()
		return nil
	case title.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case title.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Title nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TitleMutation) ResetField(name string) error {
	switch name {
	case title.FieldEmployeeID:
		m.ResetEmployeeID()
		return nil
	case title.FieldTitle:
		m.ResetTitle()
		return nil
	case title.FieldFromDate:
		m.ResetFromDate()
		return nil
	case title.FieldToDate:
		m.ResetToDate()
		return nil
	case title.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case title.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Title field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TitleMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.employee != nil {
		edges = append(edges, title.EdgeEmployee)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TitleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case title.EdgeEmployee:
		if id := m.employee; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TitleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TitleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TitleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedemployee {
		edges = append(edges, title.EdgeEmployee)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TitleMutation) EdgeCleared(name string) bool {
	switch name {
	case title.EdgeEmployee:
		return m.clearedemployee
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TitleMutation) ClearEdge(name string) error {
	switch name {
	case title.EdgeEmployee:
		m.ClearEmployee()
		return nil
	}
	return fmt.Errorf("unknown Title unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TitleMutation) ResetEdge(name string) error {
	switch name {
	case title.EdgeEmployee:
		m.ResetEmployee()
		return nil
	}
	return fmt.Errorf("unknown Title edge %s", name)
}
